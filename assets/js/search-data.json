{
  
    
        "post0": {
            "title": "Title",
            "content": "SMILES is a standard way of specifying the molecular structure of a compound into a simple string representation. The string representation of the structure in the figure above is OC(=O)C1=CN(C2CC2)c3cc(N4CCNCC4)c(F)cc3C1=O. One can easily convert these string representation(s) into 2D drawings — which makes it a popular description to be used both for ML models and visualization purposes. There are other ways to represent structures as well but SMILES is better since it is more human-readable and can be transformed into other representational types such as graphs. Since I am a data scientist and do not have a strong chemistry background, I would not go in-depth on how SMILES works. But one can go in more depth by reading the OPENSMILES documentation. In short, it is a really powerful way of representing structures and has the capability of representing different kinds of atoms, bonds, rings and even complex concepts such as branching and aromaticity. . import datamol as dm import pandas as pd . BBBP_df = pd.read_csv(&quot;data/BBBP.csv&quot;) BBBP_df.head() . num name p_np smiles . 0 1 | Propanolol | 1 | [Cl].CC(C)NCC(O)COc1cccc2ccccc12 | . 1 2 | Terbutylchlorambucil | 1 | C(=O)(OC(C)(C)C)CCCc1ccc(cc1)N(CCCl)CCCl | . 2 3 | 40730 | 1 | c12c3c(N4CCN(C)CC4)c(F)cc1c(c(C(O)=O)cn2C(C)CO... | . 3 4 | 24 | 1 | C1CCN(CC1)Cc1cccc(c1)OCCCNC(=O)C | . 4 5 | cloxacillin | 1 | Cc1onc(c2ccccc2Cl)c1C(=O)N[C@H]3[C@H]4SC(C)(C)... | . BBBP_df = BBBP_df.drop([&quot;num&quot;, &quot;name&quot;], axis=1) BBBP_df[&quot;smiles&quot;].isnull().values.any() #BBBP_df = BBBP_df.dropna() . False . Mols and smiles need to be sanitized as it will leave us with SMILES that are complete nonesense, for example, errors resulting from kekulization. . . If you were to search for the left molecule in panel (1) using an image search or a SMILES string, you might miss the right molecule in that panel. . According to the RDkit document cited in the question, the software routinely generates the alternate position of double bonds, and then (in a second step they call &quot;aromatization&quot;) labels the ring as aromatic. In panel (2), there are three possible Lewis structures contributing to the actual structure (i.e. there is resonance), so the software would have to generate all three to be able to search for identical structures. . BBBP_df[&quot;mol&quot;].isnull().values.any() BBBP_df = BBBP_df.dropna() . smiles_column = &quot;smiles&quot; mols_column = &quot;mol&quot; . def preprocess(row): mol = dm.to_mol(row[smiles_column], ordered=True) mol = dm.fix_mol(mol) if row[mols_column].isnull(): row[mols_column].dropna() return row data_clean = BBBP_df.apply(preprocess, axis=1) . data_clean . #BBBP_df[&quot;mol&quot;] = [dm.fix_mol(x) for x in BBBP_df[&#39;mol&#39;]] #BBBP_df = BBBP_df.dropna() #BBBP_df[&quot;mol&quot;] = [dm.sanitize_mol(x, sanifix=True, charge_neutral=False) for x in BBBP_df[&#39;mol&#39;]] #BBBP_df[&quot;mol&quot;] = [dm.standardize_mol(x, disconnect_metals=False, normalize=True, reionize=True, uncharge=False, stereo=True) for x in BBBP_df[&#39;mol&#39;]] #mol = dm.to_mol(row[smiles_column], ordered=True) . #BBBP_df[&quot;selfies&quot;] = [dm.to_selfies(x) for x in BBBP_df[&#39;mol&#39;]] #BBBP_df[&quot;inchi&quot;] = [dm.to_inchi(x) for x in BBBP_df[&#39;mol&#39;]] #BBBP_df[&quot;inchikey&quot;] = [dm.to_inchikey(x) for x in BBBP_df[&#39;mol&#39;]] . def preprocess_smiles(df): df[&quot;mol&quot;] = [dm.to_mol(x) for x in df[&#39;smiles&#39;]] df[&quot;mol&quot;] = [dm.fix_mol(x) for x in df[&#39;mol&#39;]] shape_before = str(df.shape[0]) df = df.dropna() shape_after = str(df.shape[0]) df[&quot;mol&quot;] = [dm.sanitize_mol(x, sanifix=True, charge_neutral=False) for x in df[&#39;mol&#39;]] df[&quot;mol&quot;] = [dm.standardize_mol(x, disconnect_metals=False, normalize=True, reionize=True, uncharge=False, stereo=True) for x in df[&#39;mol&#39;]] df[&quot;standard_smiles&quot;] = [dm.standardize_smiles(x) for x in df[&#39;smiles&#39;]] df[&quot;selfies&quot;] = [dm.to_selfies(x) for x in df[&#39;mol&#39;]] df[&quot;inchi&quot;] = [dm.to_inchi(x) for x in df[&#39;mol&#39;]] df[&quot;inchikey&quot;] = [dm.to_inchikey(x) for x in df[&#39;mol&#39;]] cleaned_data = &quot;shape prior to cleaning: &quot; + shape_before + &quot; &quot; &quot;shape after cleaning: &quot; + shape_after return df, cleaned_data data_clean = preprocess_smiles(BBBP_df) . C: Users gurka AppData Local Temp/ipykernel_25064/2893808228.py:11: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy df[&#34;mol&#34;] = [dm.sanitize_mol(x, sanifix=True, charge_neutral=False) for x in df[&#39;mol&#39;]] C: Users gurka AppData Local Temp/ipykernel_25064/2893808228.py:12: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy df[&#34;mol&#34;] = [dm.standardize_mol(x, disconnect_metals=False, normalize=True, reionize=True, uncharge=False, stereo=True) for x in df[&#39;mol&#39;]] C: Users gurka AppData Local Temp/ipykernel_25064/2893808228.py:14: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy df[&#34;standard_smiles&#34;] = [dm.standardize_smiles(x) for x in df[&#39;smiles&#39;]] C: Users gurka AppData Local Temp/ipykernel_25064/2893808228.py:15: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy df[&#34;selfies&#34;] = [dm.to_selfies(x) for x in df[&#39;mol&#39;]] C: Users gurka AppData Local Temp/ipykernel_25064/2893808228.py:16: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy df[&#34;inchi&#34;] = [dm.to_inchi(x) for x in df[&#39;mol&#39;]] C: Users gurka AppData Local Temp/ipykernel_25064/2893808228.py:17: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy df[&#34;inchikey&#34;] = [dm.to_inchikey(x) for x in df[&#39;mol&#39;]] . data_clean . p_np smiles mol standard_smiles selfies inchi inchikey . 0 1 | [Cl].CC(C)NCC(O)COc1cccc2ccccc12 | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | CC(C)NCC(O)COc1cccc2ccccc12.[Cl-] | [C][C][Branch1][C][C][N][C][C][Branch1][C][O][... | InChI=1S/C16H21NO2.ClH/c1-12(2)17-10-14(18)11-... | ZMRUPTIKESYGQW-UHFFFAOYSA-M | . 1 1 | C(=O)(OC(C)(C)C)CCCc1ccc(cc1)N(CCCl)CCCl | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | CC(C)(C)OC(=O)CCCc1ccc(N(CCCl)CCCl)cc1 | [C][C][Branch1][C][C][Branch1][C][C][O][C][=Br... | InChI=1S/C18H27Cl2NO2/c1-18(2,3)23-17(22)6-4-5... | SZXDOYFHSIIZCF-UHFFFAOYSA-N | . 2 1 | c12c3c(N4CCN(C)CC4)c(F)cc1c(c(C(O)=O)cn2C(C)CO... | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | CC1COc2c(N3CCN(C)CC3)c(F)cc3c(=O)c(C(=O)O)cn1c23 | [C][C][C][O][C][=C][Branch1][N][N][C][C][N][Br... | InChI=1S/C18H20FN3O4/c1-10-9-26-17-14-11(16(23... | GSDSWSVVBLHKDQ-UHFFFAOYSA-N | . 3 1 | C1CCN(CC1)Cc1cccc(c1)OCCCNC(=O)C | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | CC(=O)NCCCOc1cccc(CN2CCCCC2)c1 | [C][C][=Branch1][C][=O][N][C][C][C][O][C][=C][... | InChI=1S/C17H26N2O2/c1-15(20)18-9-6-12-21-17-8... | FAXLXLJWHQJMPK-UHFFFAOYSA-N | . 4 1 | Cc1onc(c2ccccc2Cl)c1C(=O)N[C@H]3[C@H]4SC(C)(C)... | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | Cc1onc(-c2ccccc2Cl)c1C(=O)N[C@@H]1C(=O)N2[C@@H... | [C][C][O][N][=C][Branch1][#Branch2][C][=C][C][... | InChI=1S/C19H18ClN3O5S/c1-8-11(12(22-28-8)9-6-... | LQOLIRLGBULYKD-JKIFEVAISA-N | . ... ... | ... | ... | ... | ... | ... | ... | . 2045 1 | C1=C(Cl)C(=C(C2=C1NC(=O)C(N2)=O)[N+](=O)[O-])Cl | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | O=c1[nH]c2cc(Cl)c(Cl)c([N+](=O)[O-])c2[nH]c1=O | [O][=C][NH1][C][=C][C][Branch1][C][Cl][=C][Bra... | InChI=1S/C8H3Cl2N3O4/c9-2-1-3-5(6(4(2)10)13(16... | CHFSOFHQIZKQCR-UHFFFAOYSA-N | . 2046 1 | [C@H]3([N]2C1=C(C(=NC=N1)N)N=C2)[C@@H]([C@@H](... | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | C[S+](CC[C@H](N)C(=O)[O-])C[C@H]1O[C@@H](n2cnc... | [C][S+1][Branch1][N][C][C][C@H1][Branch1][C][N... | InChI=1S/C15H22N6O5S/c1-27(3-2-7(16)15(24)25)4... | MEFKEPWMEQBLKI-AIRLBKTGSA-N | . 2047 1 | [O+]1=N[N](C=C1[N-]C(NC2=CC=CC=C2)=O)C(CC3=CC=... | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | CC(Cc1ccccc1)n1cc([N-]C(=O)Nc2ccccc2)[o+]n1 | [C][C][Branch1][#Branch2][C][C][=C][C][=C][C][... | InChI=1S/C18H18N4O2/c1-14(12-15-8-4-2-5-9-15)2... | SAJPRPXALCNNRQ-UHFFFAOYSA-N | . 2048 1 | C1=C(OC)C(=CC2=C1C(=[N+](C(=C2CC)C)[NH-])C3=CC... | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | CCc1c(C)[n+]([NH-])c(-c2ccc(OC)c(OC)c2)c2cc(OC... | [C][C][C][=C][Branch1][C][C][N+1][Branch1][C][... | InChI=1S/C22H26N2O4/c1-7-15-13(2)24(23)22(14-8... | IQLRWLFPGKTMDX-UHFFFAOYSA-N | . 2049 1 | [N+](=NCC(=O)N[C@@H]([C@H](O)C1=CC=C([N+]([O-]... | &lt;img data-content=&quot;rdkit/molecule&quot; src=&quot;data:i... | [N-]=[N+]=NCC(=O)N[C@H](CO)[C@H](O)c1ccc([N+](... | [N-1][=N+1][=N][C][C][=Branch1][C][=O][N][C@H1... | InChI=1S/C11H13N5O5/c12-15-13-5-10(18)14-9(6-1... | SGRUZFCHLOFYHZ-MWLCHTKSSA-N | . 2039 rows × 7 columns . smiles_column = &quot;smiles&quot; def _preprocess(row): mol = dm.to_mol(row[smiles_column], ordered=True) mol = dm.fix_mol(mol) mol = dm.sanitize_mol(mol, sanifix=True, charge_neutral=False) mol = dm.standardize_mol(mol, disconnect_metals=False, normalize=True, reionize=True, uncharge=False, stereo=True) row[&quot;standard_smiles&quot;] = dm.standardize_smiles(dm.to_smiles(mol)) row[&quot;selfies&quot;] = dm.to_selfies(mol) row[&quot;inchi&quot;] = dm.to_inchi(mol) row[&quot;inchikey&quot;] = dm.to_inchikey(mol) return row data_clean = BBBP_df.apply(_preprocess, axis=1) data_clean.head() . Urbaczek, Sascha. A consistent cheminformatics framework for automated virtual screening. Ph.D. Thesis, Universität Hamburg, August 2014. URL: http://ediss.sub.uni-hamburg.de/volltexte/2015/7349/; URN: urn:nbn:de:gbv:18-73491; PDF via Semantic Scholar |",
            "url": "https://www.neongenes.com//2021/10/22/working-with-SMILES.html",
            "relUrl": "/2021/10/22/working-with-SMILES.html",
            "date": " • Oct 22, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Writing a function in python to perform a restriction enzyme digest",
            "content": "Creating a restriction enzyme dictionary . The activity of a restriction enzyme can be defined by its recognition site on the DNA sequence and the position relative to the recognition site, at which it cuts the DNA. Let’s create a dictionary that we can use to define these restriction enzyme parameters: . Notice that the key for each entry in this dictionary is the name of the enzyme and the value is a list whose first element is the enzyme’s recognition site and second element is the position relative to the recognition site, at which the enzyme cuts the DNA. You could imagine adding a whole bunch of restriction enzymes to this dictionary, and even using as a kind of simple restriction enzyme database with which you could do digital DNA restriction experiments. One thing you would almost certainly need however is a way to keep track of which enzymes are present in the dictionary and to be able to query whether or not the dictionary has the enzyme you are interested in using. There are two very useful dictionary methods that you should know if you are going to use dictionaries in your code, and the best way to describe them is to see them in action: . # from the restriction enzyme dictionary restrictionEnzymes = {} restrictionEnzymes[&#39;bamH1&#39;] = [&#39;ggatcc&#39;,0] restrictionEnzymes[&#39;sma1&#39;] = [&#39;cccggg&#39;,2] dnaMolecularWeight = {&#39;a&#39;:313.2,&#39;c&#39;:289.2,&#39;t&#39;:304.2,&#39;g&#39;:329.2} def oligoMolecularWeight(sequence): dnaMolecularWeight = {&#39;a&#39;:313.2,&#39;c&#39;:289.2,&#39;t&#39;:304.2,&#39;g&#39;:329.2} molecularWeight = 0.0 for base in sequence: molecularWeight += dnaMolecularWeight[base] return molecularWeight def digest(sequence, enzyme): motif = restrictionEnzymes[enzyme][0] cutPosition = restrictionEnzymes[enzyme][1] fragments = [] found = 0 # lastCut = found searchFrom = lastCut while found != -1: found = sequence.find(motif, searchFrom) if found != -1: fragment = sequence[lastCut:found+cutPosition] mwt = oligoMolecularWeight(fragment) fragments.append((fragment,mwt)) else: fragment = sequence[lastCut:] mwt = oligoMolecularWeight(fragment) fragments.append((fragment,mwt)) lastCut = found + cutPosition searchFrom = lastCut + 1 . The variable found is the position of the last found restriction site, initialized to the start of the sequence to begin with. The variable lastCut stores the position at which we last cut the DNA (which may not be the same as the starting position of the restriction site). This is needed to define the starting position of the current fragment (and the end of the last one). The variable searchFrom (again, included to make the code more readable) tells us from where we need to start the next search step, which is always the next position after the one in which we previously cut the DNA strand. .",
            "url": "https://www.neongenes.com//python/bioinformatics/restriction%20enzyme/function/2021/10/18/restriction-enzyme-digest.html",
            "relUrl": "/python/bioinformatics/restriction%20enzyme/function/2021/10/18/restriction-enzyme-digest.html",
            "date": " • Oct 18, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "A primer on Apache Airflow",
            "content": "What is airflow? . Airflow is a platform used to author, schedule, and monitor workflows. It’s essentially a queuing system that runs on a metadata database and a scheduler that runs tasks. Workflows are written as Directed Acyclic Graphs (DAGs). A workflow and DAG are interchangeable. . What are DAGs? . A DAG is a collection of tasks you want to run and are organized in a way that illustrates dependencies and relationships between tasks. . The image below shows how a DAG is a unidirectional, acyclic graph, where each node in the graph is a task and edges define dependencies among tasks. There is no case where you should be able to go backwards from a forward node to one that&#39;s already been executed. . . A DAG can be broken up into smaller and smaller jobs and gives the user full control by generating dynamic pipelines written in code. Airflow DAGs are also extensible and can scale. DAGs are powerful because they allow for collaborative, manageable, and testable workflows. A bonus is that Airflow is developed in python and can interface with any python API. . . The image above shows how Airflow divides the tasks into branches so that if one fails, there is still output from the other. Also, the processing time is reduced as parallel computing occurs. The chances of failure should decrease overall as each task is independent. . How are tasks executed? . An operator represents a single task in a workflow that helps carry out your task (running a python function for example). Operators determine what actually gets to be done when your dag runs. A task is an operator when instantiated. It is something on which the worker works upon. . Airflow Architecture . Metadata — is a relational database with info on task state, such as the top ten tasks consuming the most memory, it contains all data pertaining to jobs currently running as well as historical data. . | Scheduler — decides which task to run, when, and in what order. . | Web server— the UI which is essentially a flask app that talks to the metadata. . | Executor — performs the task at ground level. The executor is a message queuing process which figures out which workers will execute which tasks. The default is the sequential executor — which cannot run tasks in parallel — meaning it can’t be used for production level code. The local executor can be used too which will run tasks till all resources on the server are at capacity. This is good for a moderate amount of DAGs. Both of these are used in single node clusters and therefore cannot be used to scaled. . | Multi node clusters — have the same components and only the scheduler and web server are placed in the same node (master), the workers are placed in a separate instance. This set up works well because it allows for scaling by letting you add more multi-node clusters (celery is the executor of choice here for python). . | . If you&#39;re not dealing with terabytes of data then it&#39;s better to have the scheduler, web server, and executor together in the master node/cluster. The downside is that this single cluster approach runs everything on the same machine, so if you make a change to a DAG/scheduler, then you need to restart the entire workflow — even tasks that were in the process of executing. Celery avoids this. . . If you do build a distributed workflow with celery then a queuing system component is needed (like Redis). For local workflows, the queuing is handled by the system. . The life cycle of a task . The scheduler periodically checks the DAG folder to see if there are any DAGS that need to be run. . | If any DAGS are found pending execution, the scheduler creates a diagram for it, which is an instantiation of a DAG in real time. . | The scheduler will update the DAG state to running in the metadata and the tasks will execute. . | The scheduler then reads the DAG and puts the tasks in order of execution into the queuing system in the form of a message. Each message contains info like DAG ID, TASK ID, and function to be executed. . | The status of these tasks changes to queued at that point. . | The executor then begins to execute tasks and sends fail/success messages for the tasks to the metadata. . | The scheduler finally updates the status of the diagram when all tasks have run to success or fail. . |",
            "url": "https://www.neongenes.com//data-engineering/python/airflow/dag/2021/04/20/airflow-primer.html",
            "relUrl": "/data-engineering/python/airflow/dag/2021/04/20/airflow-primer.html",
            "date": " • Apr 20, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://www.neongenes.com//markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://www.neongenes.com//about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://www.neongenes.com//robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}